## 题目描述

编写一个 StockSpanner 类，它收集某些股票的每日报价，并返回该股票当日价格的跨度。

今天股票价格的跨度被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。

例如，如果未来7天股票的价格是 [100, 80, 60, 70, 60, 75, 85]，那么股票跨度将是 [1, 1, 1, 2, 1, 4, 6]。

 
```
示例：

输入：["StockSpanner","next","next","next","next","next","next","next"], [[],[100],[80],[60],[70],[60],[75],[85]]
输出：[null,1,1,1,2,1,4,6]
解释：
首先，初始化 S = StockSpanner()，然后：
S.next(100) 被调用并返回 1，
S.next(80) 被调用并返回 1，
S.next(60) 被调用并返回 1，
S.next(70) 被调用并返回 2，
S.next(60) 被调用并返回 1，
S.next(75) 被调用并返回 4，
S.next(85) 被调用并返回 6。
注意 (例如) S.next(75) 返回 4，因为截至今天的最后 4 个价格
(包括今天的价格 75) 小于或等于今天的价格。
```

提示：

+ 调用 StockSpanner.next(int price) 时，将有 1 <= price <= 10^5。
+ 每个测试用例最多可以调用  10000 次 StockSpanner.next。
+ 在所有测试用例中，最多调用 150000 次 StockSpanner.next。
+ 此问题的总时间限制减少了 50%。

## 解题思路
1、将金额压入栈中，便于下次进行循环
2、因为需要求解跨度，跨度即该金额的下标减去比他小的金额的前一个金额的下标，即可以算出有多少金额连续比它小，所以需要来记录每次金额的下标，并将每次金额的下标压入一个下标栈中
3、循环判断金额栈倒数第二个元素的值是否比当前金额的值小于或等于，符合条件则将该下标移除
4、最后判断下标栈的栈长度，当栈中只有一个元素的时候，这个元素的下标 + 1 就是天数，栈中元素大于1的时候，栈顶两个元素下标之差就是天数

## 解题步骤
1、新建两个栈，一个是存放金额，一个是存放下标
2、将金额压入栈中
3、循环判断下标栈的栈顶元素对应的金额栈的元素的值是否大于当前金额，如果满足条件就将该下标从下标栈弹出
4、将当前金额的下标压入下标栈中
5、最后判断下标栈的栈长度，当栈中只有一个元素的时候，这个元素的下标 + 1 就是天数，栈中元素大于1的时候，栈顶两个元素下标之差就是天数

## 时间复杂度和空间复杂度
时间复杂度为O(n)
空间复杂度为O(n)