## 题目描述

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

**示例 1：**

![](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)
```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
```
**示例 2：**

![](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)
```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
```
**示例 3：**
```
输入：root = [1,2], p = 1, q = 2
输出：1
```

提示：

+ 树中节点数目在范围 [2, 105] 内。
+ -109 <= Node.val <= 109
+ 所有 Node.val 互不相同 。
+ p != q
+ p 和 q 均存在于给定的二叉树中。

## 解题思路

既然查找公共组件，那必然是从下向上查找最好了，从下向上查找的话，优先选择后序遍历。

最近公共祖先：通俗一点将，就是如果一个 root 的两侧有 p、q，则 root 就为 p、q 的最近公共祖先，如果 p 为 root 或者 q 为 root，则 p 或者 q 就为最近的公共祖先。

根据以上可以得出三种情况：
1. p 和 q 在 root 的子树种，且分别在 root 的两侧
2. p 等于 root，且 q 在 root 的左右子树中
3. q 等于 root，且 p 在 root 的左右子树中

## 解题步骤

根据解题思路中的三种情况，可以得出步骤：

+ 终止条件：
  1. 当 root 为空时，返回 root
  2. 当 p 或者 q 等于 root 时，返回 root
+ 递归：
  1. 递归 root 的左侧子分支，返回值记为 left
  2. 递归 root 的右侧子分支，返回值记为 right
+ 返回值：
  1. 当 left 和 right 都为空时，说明在 root 的左右子树中都没有找到 p、q，则返回 null
  2. 当 left 和 right 都不为空时，说明 p、q 在 root 的两侧，则返回 root
  3. 当 left 为空，right 不为空，说明在 left 中没有找到 p 或者 q，返回 right，有两种情况：
    - p、q 都在 root 的右侧，此时 right 就是最近公共祖先
    - p、q 其中一个在 root 的右侧，此时 p 或者 q 就是最近公共祖先
  4. 当 right 为空，left 不为空，则和 3 相似

## 时间复杂度和空间复杂度

+ 时间复杂度：O(n)
+ 空间复杂度：O(n)