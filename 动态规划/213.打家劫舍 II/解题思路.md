## 题目描述

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。

```
示例 1：

输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
```
```
示例 2：

输入：nums = [1,2,3,1]
输出：4
解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。
```
```
示例 3：

输入：nums = [1,2,3]
输出：3
```

提示：

+ 1 <= nums.length <= 100
+ 0 <= nums[i] <= 1000

## 解题思路

1. 使用动态规划
2. dp(n) 代表前 n 屋所偷的财产，dp(0) = 0
3. 由于不能偷相邻的屋子，当 n + 1 屋被偷时，n 屋不能偷，则 dp(n + 1) = dp(n - 1) + num，num 为当前屋子中的财产，即 n + 1 屋的财产，当 n + 1 屋不偷时，则偷 n 屋， 则 dp(n + 1) = dp(n)
4. 状态方程式：dp(n + 1) = Math.max(dp(n), dp(n - 1) + num)
5. 与 198 不同的是，房屋群整个布局是环形布局，即首尾相连，这样可以用话可以拆成两个单排，即第一种：
+ 不偷第一个屋子：偷屋子的范围是 [1, nums.length - 1];
+ 偷第一个屋子：偷屋子的范围是 [2, nums.length];
取两个范围的最后结果的最大值

## 解题步骤

1. 创建 dp0 = 0，dp1 = nums[0]，分别代表前 0 个屋和前 1 个屋的财产
2. 遍历 nums
3. 将 dp1 和 dp0 进行转换，dp1 为状态方程的值
4. 最后输出 dp1
5. 按偷取范围分别切割 nums 数组，取这两个范围结果的最大值

## 时间复杂度和空间复杂度

1. 时间复杂度：O(n)
2. 空间复杂度：O(1)
