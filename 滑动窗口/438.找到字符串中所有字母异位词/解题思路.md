## 题目描述

给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

异位词 指字母相同，但排列不同的字符串。
```
示例 1:

输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
```
```
示例 2:

输入: s = "abab", p = "ab"
输出: [0,1,2]
解释:
起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。
```

提示:

+ 1 <= s.length, p.length <= 3 * 104
+ s 和 p 仅包含小写字母

## 解题思路

1. 双指针和滑动窗口
2. 此题可以用 76.最小覆盖子串 的解题思路进行解答，建议先做 76 后做此题
3. 利用双指针来截取子串，进行判断是否为和 p 是异位词，是则返回索引

## 解题步骤

1. 新建值为 0 的双指针，left、right，空数组 res 作为接受结果，空的 map 字典
2. 先将 p 中的值和值的数量作为键值对存入 map 中，然后获取 map 字典的大小 mapSize
3. 将左指针向右移并且不能超过 s 的长度，当对应的值存在于 map 字典中时，将其对应的数量减一，如果该对应的数量为 0 时，则将 map 的数量 mapSize 减一，当 mapSize 的值为 0 时，则表示当前左右指针中的字符串已经全匹配 p 的字符串
4. 截取当前 right 和 left 中子串，由于当前截取子串中一定全都包含了 p 中的字符，所以判断截取的子串和 p 的长度是否相等，相等则代表一定是 p 的异位词，并把此时的 left 压入到 res，此时移动右指针，当右指针对应的值包含在 map 中时，将其对应值的数量加一，就代表 right 和 left 中的子串不全包含 p 中的值

## 时间复杂度和空间复杂度

+ 时间复杂度：O(n)
+ 空间复杂度；O(n)