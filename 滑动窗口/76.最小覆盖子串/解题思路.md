## 题目描述

给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。

**注意：**

+ 对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。
+ 如果 s 中存在这样的子串，我们保证它是唯一的答案。
 
```
示例 1：

输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
```
```
示例 2：

输入：s = "a", t = "a"
输出："a"
```
```
示例 3:

输入: s = "a", t = "aa"
输出: ""
解释: t 中两个字符 'a' 均应包含在 s 的子串中，
因此没有符合条件的子字符串，返回空字符串。
```

提示：

+ 1 <= s.length, t.length <= 105
+ s 和 t 由英文字母组成

进阶：你能设计一个在 o(n) 时间内解决此问题的算法吗？

## 解题思路

1. 双指针，窗口滑动
2. 找出最小长度的覆盖子串并返回 

## 解题步骤

1. 新建值为 0 的双指针，left、right，空字符串 ans 作为接受结果，空的 map 字典
2. 先将 t 中的值和值的数量作为键值对存入 map 中，然后获取 map 字典的大小 mapSize
3. 将左指针向右移并且不能超过 s 的长度，当对应的值存在于 map 字典中时，将其对应的数量减一，如果该对应的数量为 0 时，则将 map 的数量 mapSize 减一，当 mapSize 的值为 0 时，则表示当前左右指针中的字符串已经全匹配 t 的字符串，即为覆盖子串
4. 此时移动右指针，当右指针对应的值包含在 map 中时，将其对应值的数量加一，就代表 right 和 left 中的子串不全包含 t 中的值，最后输出最小长度的子串

## 时间复杂度和空间复杂度

+ 时间复杂度：O(n)
+ 空间复杂度：O(n)